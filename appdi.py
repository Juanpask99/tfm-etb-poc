# -*- coding: utf-8 -*-
"""AppDI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EAjXblIc4G5ZApnUnAi_7LhZpZz7pfr1
"""

import streamlit as st
from google.cloud import documentai
import os
import io
import json

# --- FUNCIÓN DE API GENÉRICA ---
# Esta función ahora solo se encarga de llamar a un procesador de DocAI
# Puede ser un clasificador O un extractor, por eso es genérica.
def process_document_api(project_id, location, processor_id, file_content, mime_type, key_content):
    """
    Función genérica para llamar a cualquier procesador de Document AI.
    Devuelve el objeto 'document' completo.
    """
    
    opts = {"api_endpoint": f"{location}-documentai.googleapis.com"}
    
    try:
        client = documentai.DocumentProcessorServiceClient.from_service_account_info(
            key_content, client_options=opts
        )
    except Exception as e:
        st.error(f"Error al cargar las credenciales de GCP. Asegúrate de que el JSON es correcto. Detalle: {e}")
        return None

    processor_name = client.processor_path(project_id, location, processor_id)
    raw_document = documentai.RawDocument(content=file_content, mime_type=mime_type)
    request = documentai.ProcessRequest(name=processor_name, raw_document=raw_document)

    try:
        result = client.process_document(request=request)
        return result.document
        
    except Exception as e:
        st.error(f"Error al conectar con la API de Document AI: {e}")
        return None

# --- FUNCIÓN PARA PARSEAR ENTIDADES EXTRAÍDAS ---
def parse_extracted_entities(document):
    """
    Toma un documento procesado por un EXTRACTOR
    y convierte sus entidades en un JSON (dict) limpio.
    """
    extracted_data = {}
    if document is None or not document.entities:
        return extracted_data
        
    for entity in document.entities:
        key = entity.type_
        value = entity.mention_text.strip()
        # Maneja el caso de que una misma entidad (ej. 'items_comprados') aparezca varias veces
        if key in extracted_data:
            if isinstance(extracted_data[key], list):
                extracted_data[key].append(value)
            else:
                extracted_data[key] = [extracted_data[key], value]
        else:
            extracted_data[key] = value
            
    return extracted_data

# --- Interfaz de Streamlit ---

st.set_page_config(layout="wide")
st.title("Prueba de Concepto (PoC) TFM - ETB (Versión 2.0)")
st.subheader("Pipeline de Clasificación y Extracción con Google Document AI")

# --- Barra Lateral (Sidebar) para Configuración ---
st.sidebar.header("Configuración de GCP")
st.sidebar.markdown("""
Esta PoC demuestra un pipeline de 2 pasos:
1.  **Clasificación:** Identifica el tipo de documento.
2.  **Extracción:** Aplica el modelo especialista correcto.
""")

st.sidebar.subheader("Credenciales Comunes")
gcp_project_id = st.sidebar.text_input("1. Project ID de GCP:", help="El ID de tu proyecto de GCP, ej: 'sapient-hub-123456'")
gcp_location = st.sidebar.text_input("2. Location de los Procesadores (ej: us):", "us")
uploaded_key = st.sidebar.file_uploader("3. Sube tu JSON Key de Service Account:", type=["json"])

st.sidebar.subheader("Procesadores Especialistas")
# IDs para cada uno de tus modelos entrenados en Document AI Workbench [1]
gcp_classifier_id = st.sidebar.text_input("4. Processor ID del CLASIFICADOR:", help="El ID de tu 'Custom Classifier'")
gcp_contract_extractor_id = st.sidebar.text_input("5. Processor ID del Extractor de CONTRATOS:", help="El ID de tu 'Custom Extractor' para contratos")
gcp_invoice_extractor_id = st.sidebar.text_input("6. Processor ID del Extractor de FACTURAS:", help="El ID de tu 'Custom Extractor' para facturas")


# --- Área Principal de la Aplicación ---
uploaded_doc = st.file_uploader("Carga tu documento (Contrato, Factura, etc.):", type=["pdf"])

st.markdown("---")

if st.button("Procesar Documento (Clasificar y Extraer)"):
    
    # Validaciones
    if not all([gcp_project_id, gcp_location, gcp_classifier_id, gcp_contract_extractor_id, gcp_invoice_extractor_id]):
        st.error("Error: Faltan uno o más IDs de procesador en la barra lateral.")
    elif uploaded_key is None:
        st.error("Error: Sube el archivo JSON de la cuenta de servicio.")
    elif uploaded_doc is None:
        st.error("Error: Sube un archivo PDF.")
    else:
        try:
            # --- Autenticación ---
            key_dict = json.load(io.StringIO(uploaded_key.getvalue().decode("utf-8")))
            doc_bytes = uploaded_doc.read()
            
            # --- PASO 1: CLASIFICACIÓN ---
            st.info(f"**Paso 1:** Clasificando documento... (Llamando al Procesador: {gcp_classifier_id[:10]}...)")
            
            classifier_doc = process_document_api(
                project_id=gcp_project_id,
                location=gcp_location,
                processor_id=gcp_classifier_id,
                file_content=doc_bytes,
                mime_type="application/pdf",
                key_content=key_dict
            )
            
            if classifier_doc is None or not classifier_doc.entities:
                st.error("Error en la clasificación. El clasificador no devolvió entidades.")
            else:
                # El clasificador devuelve la mejor coincidencia como una entidad
                # Ordenamos por confianza y tomamos la más alta
                classification = max(classifier_doc.entities, key=lambda e: e.confidence)
                doc_type = classification.type_
                doc_confidence = classification.confidence
                
                st.success(f"**Paso 1 Completado:** Documento identificado como: **{doc_type}** (Confianza: {doc_confidence:.2%})")

                # --- PASO 2: EXTRACCIÓN (Routing) ---
                processor_to_use = None
                
                # Lógica de enrutamiento basada en el resultado de la clasificación
                if doc_type == "contrato": # Asegúrate que 'contrato' coincida con la etiqueta de tu clasificador
                    processor_to_use = gcp_contract_extractor_id
                elif doc_type == "factura": # Asegúrate que 'factura' coincida con la etiqueta de tu clasificador
                    processor_to_use = gcp_invoice_extractor_id
                else:
                    st.warning(f"No se ha configurado un extractor para el tipo de documento: '{doc_type}'")

                if processor_to_use:
                    st.info(f"**Paso 2:** Extrayendo datos para '{doc_type}'... (Llamando al Procesador: {processor_to_use[:10]}...)")

                    extractor_doc = process_document_api(
                        project_id=gcp_project_id,
                        location=gcp_location,
                        processor_id=processor_to_use,
                        file_content=doc_bytes,
                        mime_type="application/pdf",
                        key_content=key_dict
                    )
                    
                    if extractor_doc:
                        st.success(f"**Paso 2 Completado:** ¡Extracción finalizada!")
                        
                        # Parsear los resultados del extractor
                        extracted_data = parse_extracted_entities(extractor_doc)
                        
                        col1, col2 = st.columns(2)
                        with col1:
                            st.subheader(f"Datos Estructurados Extraídos ({doc_type})")
                            st.json(extracted_data)
                            st.markdown("""
                            **Valor para el TFM:** Esta salida JSON es el dato
                            estructurado que alimentaría a BigQuery para los reportes 
                            automáticos en Looker.
                            """)

                        with col2:
                            st.subheader("Texto Completo (OCR)")
                            st.text_area("Texto OCR", extractor_doc.text, height=400)
                    else:
                        st.error("Error durante la fase de extracción.")

        except Exception as e:
            st.error(f"Ocurrió un error general: {e}")
            st.error(f"Ocurrió un error general: {e}")
